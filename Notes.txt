Stack:
													
1.Push at bottom
    -> when empty push element
    -> top = s.pop()
    -> push(top) in backtracking

2. Reverse Stack
    -> top = s.pop()
    -> reverse(s)
    -> push at bottom(s, top) backtracking step



Queue:

1. 1st Non-repeating letter ***
    -> a freqency arr[26] and a Character queue
    -> loop the string => c = s.charAt(i)
    -> increase the freqence of character freq[c-'a']++
    -> add the character (c) to the queue
    -> remove "c" from queue while !isEmpty() and freq[q.peek()-'a'] > 1
    -> if q.isEmpty() sot("-1") else sot(q.peek())

2. Interleave two halfs of Queue
    *even length case only possible
    -> add last half element of queue in another queue
    -> create a final queue using the two queues
    -> add 1st element from Q1 and 2nd element from Q2



Linked List:

1. Reverse Linked List
    -> point the tail at the head
    -> Three pointers prev, curr and nxt
    -> prev = null, curr = head and nxt = curr.next (initially its null)
    -> while ( curr != null): 
	inside the while loop initialize the nxt pointer to curr.next,
        	we would reverse the links between the nodes by pointing the 
 	curr.next to the prev pointer and the next of the nxt pointer 
	to the curr pointer, after this we would update the prev pointer
	to point at curr pointer and the curr pointer will point at nxt.
    -> lastly we would update our original head == prev.

2. Detect and Remove Cycle (Floyd's Algo)
* we use fast and slow pointer appoach to find the cycle in the linked list.
    -> fast += 2 and slow += 1
    -> if they meet at any point which means a cycle exists in the linked list (LL)
    -> when they meet stop the loop and initialize slow with head (slow == head)
    -> use a prev pointer to track the prev node (prev = fast inside while loop)
    -> increase both fast and slow pointer by 1 (while slow != fast)
    -> when they meet again => prev.next = null

3. Check Palindrome **
*we can simply push the elements of our linked list in an arrayList and
check if the arrayList is a palindrome but we would be using the slow 
fast pointer approach to find the center of linked list and the concept 
of reversing half linked list.
    -> find the middle of the list
    -> reverse the second half of the list
    -> compare the 1st and the reversed 2nd half of the list

4. Mergesort
    -> first find the mid of the linked list
    -> return type of the function will be node
    -> right head will be the next of mid
    -> point the next of mid to null this would create to linked list
    -> for left part call for head and for right call for mid.next
    -> lastly call the merge function
    -> create a new linked list with a single node(-1) and temp pointing at its head
    -> merge function will be similar to the one used in arrays

5. Reverse DLL
* just add a line curr.prev = next in the code we used to reverse a SLL.



Recursion & Backtracking:

1. Subset
    -> Yes condition (ans + character)
    -> No condition (ans, pass empty string)

2. Permutation
    -> for loop (recursion inside it)
    -> newString = substr(0, i) + substr(i+1)
    -> func( newString, ans + c)
    -> c = character remove from original string

3. Qiuck Sort **
    -> s >= e return
    -> pivot = choose the last element
    -> i = starting index - 1
    -> arr[j] < pivot = perform swap
    -> call for left and right part of pivot

4. Merge Sort **
    -> s >= e return
    -> call for s to mid and mid+1 to e
    -> perform merge on left and right part
    -> left = 0 to mid-s+1 (size)  arr[i+s]
    -> right = 0 to e-mid (size)   arr[i+mid+1]

5. nQueens ***
    -> have a char[][] 2d array i.e. board[][] = new char[n][n] of size n X n
    -> a row variable to track the no. of rows
    -> when the row becomes 0 print he board and return
    -> for every board[row][col] put it equal to 'Q'
    -> call the recursive function function and increase the row by one
    -> remve the 'Q' from board[row][col] == 'x' in the backtracking step
    -> create and isSafe function to check if the position of the queen is safe or not:
	1. check straight upwards (col remains constant)
	2. check diagnol left
	3. check diagnol right (tricky one)



BT (Binary Tree):

1. Level Order Traversal
    -> create a Queue <Node> q = new LinkedList<>();
    -> run a while loop until q is empty
    -> Node curr = q.remove()
    -> if curr is null there are two cases:
 	1. if 'q' gets empty break
	2. else print next line and add 'null' to queue
    -> if curr is not null then:
	1. print the data
	2. add curr.left to the queue if it exists
	3. add curr.right to the queue if it exists

2. kth ancestor of a node 
    -> create a function 'kth' that takes root node, n and k as the input
    -> if root becomes null return -1
    -> if we found n i.e root.data == n then return 0
    -> call for root.left and store in int left
    -> call for root.right and store in int right
    -> if both are -1 return -1 to the main function
    -> else create a max variable and store max of both (left, right) +1 in it
    -> if max == k print root.data
    -> lastly return max

3. Lowest Common Ancestor
    -> create a function 'lca' that takes root node an int 'a' and 'b' as the input
    -> if root becomes null return null
    -> if root.data become equal to either a or b return root
    -> call for root.left and store in Node left
    -> call for root.right and store in Node right
    -> if both left and right are not null return root
    -> lastly if left becomes null return right and vice versa
    (return left == null ? right : left)

4. Min distance b/w 2 nodes
    -> create a distance function that takes root node, a and b as inputs
    -> find the LCA of a & b and store it in Node lca
    -> find distance b/w lca and 'a' using distUtil function and store in int d1
    -> find distance b/w lca and 'b' using distUtil function and store in int d2
    -> return d1 + d2 from distance function
    -> distUtil function takes the lca and n as the input
    -> if root becomes null return -1
    -> if root.data becomes equal to n return 0
    -> call for root.left and store in int left
    -> call for root.right and store in int right
    -> if both become -1 return -1
    -> if one of the two becomes -1 return the other variable+1
    (return left == -1 ? right+1 : left+1)

5. Tronsform to Sum Tree
    -> if root == null return 0;
    -> call for the left and store in int left
    -> call for the right and store in int right
    -> create a variable data and assign it with root.data
    -> root.left == null ? 0 : root.left.data, store the value in newLeft
    -> root.right == null ? 0 : root.right.data, store the value in newRight
    -> now change value of root.data with (left + right + newLeft + newRight)
    -> lastly return data (it contains the value of the root node) 

6. Top View
    -> create a Info class that has an int hd (horizontal distance) and Node node
    -> using Info class create a Queue
    -> create a HashMap <Integer, Node>  m
    -> create two variables min and max to store the min and max node (initially zero)
    -> add new Info(0, root) to the queue as the distance of root node is zero
    -> same as lvlOrder traversal add null to the queue
    -> traverse the queue using while loop 
    -> Info curr = q.remove()
    -> if curr is null:
	1. if q becomes empty then break the loop
   	2. else add null to the queue
    -> else check if the curr.hd exists in the map or not
    -> if does not exist then put the curr.node and curr.hd in the map
    -> if curr.left.node is not null add new Info(curr.hd-1, curr.node.left) to the queue
    -> in the same if statement update min = Math.min(min, curr.hd-1)
    -> if curr.right.node is not null add new Info(curr.hd-1, curr.node.right) to the queue
    -> in the same if statement update max = Math.max(max, curr.hd+1)
    -> after while loop run a for loop from min to max and output map.get(i).data

6. Sub tree of another tree ***
    (covers 2-3 questions)
    -> create a function check that take to inputs Node root and Node subroot
    -> if root == null return false
    -> if root.data == subroot.data call isIdentical function
    -> if isIdentical gives true return true to the main function
    -> lastly return check(root.left, subroot) || check(root.right, subroot)
    -> in isIdentical function first check if root == null && subroot == null, return true
    -> else if root == null || subroot == null || root.data != subroot.data then return false
    -> now if isIdentical(root.left, subroot) gives false return false to the main function
    -> and if isIdentical(root.right, subroot) gives false return false to the main function
    -> lastly return true in isIdentical function



BST (Binary Search Tree):

1. Build BST 
    -> pass root and the data to the function
    -> if root is null make root the new Node containing data and return it
    -> if data is smaller than root.data then insert in the left subtree
    -> if data is greater than root.data then insert in the right subtree
    -> lastly return root return root
    -> print inorder sequence to check if the tree build is correct or not

2. Delete nodeâ€Ž
    -> create a function that takes the root node an the value (to be deleted) as inputs
    -> if data is greater than the root node call the funtion for the right subtree
    -> else if data is smaller than the root node call the fucntion for the left subtree
    -> else, this is the case we found the node to be deleted
    -> inside the else statement delete the node 
    -> 1st case check is root.right and root.left both are null, if yes return null
    -> 2nd case check if root.right is null, if so return root.left
    -> root.left is null return root.right
    -> 3rd case find the inorder successor and then delete the node
    -> inorder successor is the left most node in the right subtree of a node
    -> update root.data with inorder successor.data
    -> root.right = delete(root.right, inorder successor.data)
    -> in the end return root

3. Root - Leaf paths
    -> create a function that takes the root node and an AL <Integer> path
    -> if root == null return
    -> add the root.data to the path
    -> if both left and right nodes become null print the AL 'path'
    -> call the function for root.left
    -> call the function for root.right
    -> remove the last element from the AL 'path'
    -> backtracking step: path.remove(path.size() - 1)

4. Validate BST
    -> create a boolean function that takes three nodes as input: root, min and max
    -> if root == null return true
    -> if the min node is not null and its data is greater than the root.data return false
    -> else if max node is not null and its data is smaller than the root.data return false
    -> call for the left and pass root as the max 
    -> call for the right as pass root as the min
    -> lastly return (left && right)

5. Sorted array to BST 
    -> create a function that takes an array, start and ending index as inputs
    -> if the s (starting index) becomes greater than e (ending index) return null
    -> calculate min i.e. (s+e)/2
    -> create a node using arr[mid] 
    -> call for root.left = create(arr, s, mid-1)
    -> call for root.right = create(arr, mid+1, e)
    -> lastly return the root node

6. Larges BST ***
    -> create a global varialble => int maxBst = 0
    -> create a Info class that stores isBst(boolean), size, min and max of a BST
    -> create a Info type function that take root node as the input
    -> if root == null return new Info with:
	isBst = true, size = 0, min = +infinity and max = -infinity
    -> call for left and store in Info left variable
    -> call for right and store in Info right variable
    -> now size = left.size + right.size + 1
    -> min = min of root.data and min of (left.min and right.min)
    -> max = max of root.data and max of (left.max and right.max)
    -> if root.data is less than left.max || root.data is greater than right.min 
	return new Info (false, size, min, max)
    -> if isBst for both left and right is true update maxBst = Math.max(maxBst, size) 
         	return new Info (true, size, min, max)
    -> lastly return new Info (false, size, min, max)

7. Merge 2 BST:
    -> AL <Integer> inorder
    -> add values in AL = inorder from both BSTs
    -> sort (inorder)
    -> inorder (sorted array) to BST



Heap (Priority Queues):

-> PriorityQueue <Integer> pq = new PriorityQueue<>( Comparator.reverseOrder() );
    -> to sort the priority queue in descending order.

-> class Name implements Comparable<Name> 
    @override
    public compareTo(Name n)
              return ( this.rank - n.rank )   (ascending order)
	    return ( n.rank - this.rank )   (descending order)

-> children <= parent (max heap)
-> children >= parent (min heap)

-> parent = (index-1)/2
-> left = 2*index + 1		(0 based indexing)
-> right = 2*index + 2

-> CBT(complete binary tree):
    It is a tree which has all the levels completely filled
    except the last left, node are fill from left to right.
         
1. Sliding Window:
    -> PriorityQueue of Pair class type
    -> Pair class uses implements Comparable function (val, idx)
    -> p.val - this.val (descending order)
    -> add first k elements to PQ 
    -> res array = n-k+1 (size of the answer array) 
    -> res[0] = p.peek().val (the first value in our priority queue)
    -> while index of 1st element in pq is <= (i-k) => q.remove() 



Hashing:

-> HashMap <key(type), value(type)> m = new HashMap<>()    (no defined order of element)
-> LinkedHashMap <K,V> m = new LinkedHashMap<>()    (output elements in the same order added to the map)
-> TreeMap <K,V> m = new TreeMap<>()    (stored and outputs element in sorted order, sorting based on keys)

1. Majority Element
    -> let number be the key and occurence the value
    -> if m.contains(number) increase occurence
    -> output the max occured m.get(key) > max (update max)

2. Anagram
    -> add the characters of 1st string into a hashMap
    -> HashMap < Character, Integer (occurence) > m = new HM<>()
    -> check if( m.get(character of 2nd string) != null) exists in map or not
    -> now compare if(m.get(character of 2nd string) == 1) m.remove(ch)
    -> else decrease the value of occurence ( m.put(ch, m.get(ch)-1) )
    -> if does not exists in 1st string (map) return false
    -> if map isEmpty() return true  ( return m.isEmpty() )

3. Subarray Sum 0**
    -> HashMap <sum, index> m => we will store the index of sum
    -> if we find sum in our map update len (largest subarray)
    -> subLen = j - m.get(sum) length of the subarray with sum 0 
    -> compare it with len = Math.max(len, subLen)   

*Here if we get the sum again at any point in the array it means that the sum 
  we calculated has already occured before in the array and if we take the 
  sum of the elements between the current index (where we found the sum) 
  and the previous index+1 (where we found the sum 1st time) it would be 0.
  j - m.get(sum) would give us the length of the current subarray with sum = 0.
  This works only when we need to find the subarray with max length, we can
  output the largest subarray but we cannout output all the subarrays with 0 sum.  	

4. Subarray Sum k***
    -> sum(j)-sum(i) == k we can deduce  sum(j)-k == sum(i)
    -> HashMap <sum, count> m => we would store freqency of sum
    -> put sum=0 and count=1 by default in the map
    -> if we find the sum-k in our map we would update the ans
    ->  ans += m.get(sum-k) => here we will add the count of the sum in ans
    -> we would always store our sum/increase its frequency in each step
    -> m.get(sum, m.getOrDefault(sum, 0)+1)
    -> lastly output the ans


-> HashSet <Integer> s = new HashSet<>() (unodered, no defined order)
	-> Iterator it = set.iterator()
  	-> while ( it.hasNext() ) sot( it.next() )	
	-> for ( dataType variableName : HashSetName )

-> LinkedHashSet <Integer> s = new HashSet<>()  (output in the same order we inputed)
-> TreeSet <Integer> s = new TreeSet<>()  (sorted in ascending order)



Tries:

* tries are prefix trees also known as re'trie'val (the name comes from here) trees which work 
on prefix of words, the are k-nary trees and are bulky, requires huge amount of space but gives us 
a nice time complexity, as the height of the tree decreases the time complexity of also decreases.
k-nary -> number of children of a node can be from 0 to k.

Creating
    -> define a Node class with an array of nodes[26] and a boolean EndOfWord (eow)
    -> create a constructor and initialize nodes[26] = null using forLoop
    -> create root node ( Node root = new Node() ) that remains empty
Inserting
    -> initialize a curr node == root node
    -> traverse the given word and store the index of the character in idx variable
    -> if the character does not exist create a node 
    -> point curr at the children that exists/is created 
    -> after exiting the for loop eow == true
Searching
same as inserting just if the index does not exist return false and at the end return eow

1. Word Break ***
    -> insert the array of words into a trie
    -> create a function wordBreak that takes the key as the input
    -> using a for loop traverse the key string
    -> search for the key.substring(0,i) in the try
    -> call wordBreak for the left part if the key.substring(i)
    -> if both gives the ouput as true return true
    -> if the length of key becomes 0 return true (base condition)
    -> finally return false 

2. Prefix Problem *****
    -> add another property frequency(freq) to the Node class
    -> initialise it by 1 when creating a Node
    -> insert the node and if already present increase the freqency

*Note: frequency of root node should be initialized as -1 before passing to the function
    -> pass two parameters root and an empty string (ans) to the function
    -> if root becomes null return
    -> if the freq of root becomes 1 output the answer and then return
    -> traverse all the childrens of root using a for loop
    -> if the children is not null call the function for the children and add the word to the an
    -> if we are using stringBuilder (inside for loop):
                char c = (char)(i+'a');
                ans.append(c);
                prefix(root.children[i], ans);
                ans.deleteCharAt(ans.length()-1);

3. Longest word with all Prefixes
    -> declare an ans string outside the function (global variable)
    -> pass the root and a stringBuilder(SB) to the function
    -> travese each children using a for loop
    -> if root.children[i] is not null and eow is true append the char in SB
    -> update ans with temp value if the temp is greater than the ans string
    -> call function for the children
    -> remove the last letter from the temp in backtracking step 

4. Unique Substrings ***
(unique concept of prefix and suffix used in this question)
Trie is also known as prefix tree that stores all the unique prefix of given words. Like in array of words
arr[] = {'apple', 'app', 'apple'} the prefix 'app' has occured 3 times but the Trie would store it only once.
So we will store all the prefix of all the suffix of the given string in the Trie.
    -> using a for loop traverse the given string
    -> create substring (suffix) by removing the first letter i.e str.substring(i)
    -> insert the substring in the Trie data structure
    -> now we have to count the number of nodes present in the Trie
    -> if root becomes null return 0
    -> use for loop to traverse all the children
    -> if any children is not null add it to the count
    -> call the function for that child
    -> lastly return count + 1 (1-> the root node)



Graphs:
*Network of nodes.

Properties:
1. Vertex (also know as the node witch stores the value)
2. Edge (path between two nodes/vertices)
3. Weight (it is the value of the edge, can be -ve or +ve)

There are three type of edges:
1. Uni-directed (can reach a node but cannot come back to the previous node through same path)
2. Bi-directed (can travel both sides forwrd as well as backward)
3. Undirected (no direction give can travel in any directions if path exists)


1. BFS (breadth first search)

*we start from the source node and visit all the neighbours/children of the current node we are on
and then move to the next node and repeat the same, we use a boolean vis[] array to keep check of 
the nodes we have already visited.
    -> it is an iterative function
    -> create a queue 'q' and add the source node in the queue (i.e 0)
    -> create a boolean vis[] array if size equal to the graph.length;
    -> traverse the queue using while loop until it gets empty
    -> curr = q.remove()
    -> now print curr and mark current as visited
    -> now using a for loop travers all the nodes connected to the curr node
    -> 0 to graph[curr].size() 
    -> Edge e = graph[curr].get(i)
    -> add the destination node (i.e e.dest) into the queue


2. DFS (depth first search)

*we start from the given source node and go to the 1st neighbour until we reach the last node.
Note: a graph could have move than one dfs traversals.
    -> it is a recursive function
    -> pass the graph, current node (curr) and the vis[] array to the function
    -> mark the curr node visited after printing the curr node
    -> using a for loop traverse graph[curr]
    -> Edge e = graph[curr].get(i)
    -> if the e.dest is not visited call the function for e.dest


Q 1. Has Path*
    -> pass graph, source, destination and vis[] array to the function
    -> if(source == destination) return true
    -> mark vis[source] == true
    -> traverse graph[curr] using for loop
    -> Edge e = graph[curr].get(i)
    -> check 2 conditions (&&):
	1. !vis[e.dest]
 	2. function(graph, source == e.dest, destination, vis)
    -> if both are true return true
    -> lastly return false        


3. Connected Components

They are set of vertices that are connected to each other through an edge and we can reach every other node from 
each node inside one connected component, a BST is also a graph. To findconnected components we use BFS and DFS in 
two parts. 1st part is the loop to traverse all the nodes in the graph and the second function is the helper/util function.
	
	-> pass the AL <Edge>[] graph to the bfs function
 	-> create a boolean[] vis array of size graph.length
          -> for loop 0 to graph.length
	-> *check if not visited (don't check in the case of DFS)
	-> run the bfsUtil function in it passing the graph and vis[] array in the function
	-> run the dfsUtil function in it passing the graph, i (curr node) and vis[] array 
	

 	bsfUtil
	-> create a queue of integer type
	-> add 0 as initial element to the queue
 	-> curr = q.remove()
 	-> if the not visited mark visited and print data 
	-> for loop 0 to graph[curr].size() traversing all the neighbours of curr node
	-> Edge e = graph[curr].get(i)
	-> add e to the queue q.add(e)

	dfsUtil
	-> print the curr node
	-> mark it as visited
	-> travers all its neighbours 0 to graph[curr].size()
 	-> Edge e = graph[curr].get(i)
	-> if not visited call the function for e.dest


4. Cycle Detection (undirected graph)
(45min+)

Approach (dfs used):
If we are on a node and all the neighbours of that nodes already exists it means that there exists another path
to reach those nodes, in this case cycle exists. There are three cases for a nodes:

case 1:
	vis[neighbour] -> true & parent -> false
	In this case return true as the cycle exists because one of the neighbour of the current node is
	already visited and it is not the parent of the current node so there exists another path to reach
	that node which means cycle exists in the graph.

case 2:
	vis[neighbour] -> true & parent -> true
	In this case the neighbour of the current node is visited and is also the parent of the current node 
	so in this case we continue as we cannot say anything if the cycle exists or not.

case 3:
	vis[neighbour] -> false
	In this case we normally use dfs to traverse as the neighbour is not visited.

*Note: we will use the same method used in connected componets to traverse the graph. 
    -> create a detect (boolean) function that takes AL <Edge>[] graph as the input
    -> create a boolean array and traverse all the nodes using for loop
    -> if the node is not visited call the detectUtil funtion
    -> pass the graph, vis array, current node and the parent(initially -1) to the 'util' function
    -> inside 'util' funtion make the curr node visited == true
    -> run a for loop from 0 to graph[curr].size()
    -> Edge e = graph[curr].get(i)
    -> if e.dest is not visited run the 'util' function for e.dest as curr node and curr as its parent
    -> if the util function for e.dest return true then return true
    -> in else case if e.dest is visited && e.dest != parent of curr node return true
    (e.dest != par means that the neighbour is not the parent of our current node)
    -> lastly return false in both the functions


5. Bipartite Graph
(1hr +)

*Defination: It is a graph whose vertices can be divided into two independent sets U and V such that every 
edge(u, v) either connects a vertex from U to V or a vertex from V to U. In other words from every edge(u, v)
either u belongs to U and v belongs to V or u belongs to V and v belongs to U. We can also say that there is no
edge that connects the vertex of same set.

Approach (bfs used):
We are going to use colors (two different) to divide the graph into two parts. We will be using a color array.
-1 -> no color
0 -> yellow
1 -> blue

case 1:
	color[neighbour] = same
	return false

case 2:
	color[neighbour] = different
	continue

case 3:
	color[neighbour] = no color
	give it a different color

    -> create bipartite function and pass AL <Edge>[] graph to the function
    -> create color array of size graph.length
    -> initialize all the values -1 in the col array
    -> create a queue
    -> traverse the graph using the for loop
    -> check if col[i] == -1
    -> if true then make col[i] = 0 and add i into the queue
    -> now run a while loop unit queue is not empty
    -> int curr = q.remove()
    -> now for loop from 0 to graph[curr].size()
    -> Edge e = graph[curr].get(i)
    -> now check if col[e.dest] == -1
    -> if true create a next color variable(nxtCol)
    -> initailize it with the opposite color(i.e of the curr node) 
    -> nxtCol = (col[curr] == 0) ? 1: 0
    -> put the color of the neighbour node as nxtCol (col[e.dest] == nxtCol)
    -> add e.dest to the queue
    -> in else if condition check if the neighbour and the curr node has the same color
    -> else if(col[e.dest] == col[curr]) is true, they have same color so return false
    (else if condition corresponding to if(col[e.dest] == -1) )


6. Cycle Detection (directed graph)

Approach:
We will be using a modified DFS approach with an explicit stack.
implicit -> the stack which is formed while execution a recursive function
explicit -> the stack that we make other than the recursive stack

We will use a boolean stack to store the visited neighbours, if the neighbours are present in the stack it 
would return true, else if there are no neighbours it would return false.

    -> create a detect function which takes AL <Edge>[] graph as the input
    -> create a boolean vis[] and stack[] array of size = graph.length
    -> traverse the graph using for loop from 0 to graph.length
    -> if any index is not visited run 'util' funtion for it
    -> 'util' function take the graph, i-> curr node, vis[] and stack[] as input
    -> in 'util' make vis[curr] & stack[curr] == true
    -> for loop from 0 to graph[curr].size()
    -> Edge e = graph[curr].get(i)
    -> if e.dest exists in the stack return true to main function
    -> if e.dest is not visited && 'util' for e.dest give true, return true to main function
    -> when the for loop ends put stack[curr] = false (popping out of the stack)
    -> lastly return false in both the functions

7. Topological Sort

Directed
Acyclic 		Topological sort is used on these graphs (DAGs)
Graphs

It is a linear order of vertices such that every directed edge u -> v, the vertex u comes before v in order, we 
use dfs to traverse the graph and stack to store the nodes (which comes 1st and which comes last).

    -> create a topSort function which takes AL <Edge>[] graph as input
    -> create a visited array and a stack of integer type
    -> use a for loop to traverse all the nodes of the graph, 0 to graph.length
    -> if an index is not visited run the 'util' function for the index
    -> 'util' function takes graph, i-> curr node, vis[] and stack s as inputs
    -> in 'util' function mark curr nodes as visited
    -> for loop form 0 to graph[curr].size;
    -> Edge e = graph[curr].get(i)
    -> if e.dest is not visited run the 'util' function for e.dest as curr node
    -> after the loop ends push curr in the stack 
    -> output the stack values in the topSort function after the for loop


8. Kahn's Algorithm
(1hr+)

(topological sort using BFS approach)
in-degree -> number of edges coming into the node
out-degree -> number of edges going out of the node

Approach:
We will calculate the in and out degree of each node. 
** In a DAG there always exists a node which has in-degree of 0 and a node that has out-degree of 0.

    -> create a function inDegree to calculate the indegree of each node
    -> the inDegree function takes the graph and an array indeg[graph.length] as inputs
    -> using a for loop travers the nodes of the  graph 0 to graph.length
    -> using a nested loop traverse the arrayList associated with each node graph[i].size()
    -> Edge e = graph[i].get(j)
    -> increase the indegree of e.dest by one indeg[e.dest]++
    (as there exists one path to reach the node so number of incoming edges (indegree) will be increased)
    -> now for the topSort (main function), take graph as the input
    -> create a new array indeg[], pass the array and the graph to the inDegree function
    -> now the indeg[] array stores the indegree of each node
    -> create a queue of integer type and add all the nodes with indegree == 0 into the queue
    -> using a while loop traverse the queue
    -> int curr = q.remove(), print curr
    -> for loop 0 to graph[curr].size()
    -> Edge e = graph[curr].get(i)
    -> now decrease the indegree of e.dest = indeg[e.dest]--
    -> if indeg[e.dest] becomes 0 add it to the queue


Q 2. All Path 
(Easy Question)
    -> create a function paths that takes the graph, src, dest and a string path as input
    -> base: if the src == dest print path+src and return
    -> using a for loop travere the neighbours of src node i.e from 0 to graph[src].size()
    -> Edge e = graph[src].get(i)
    -> call the path function for e.dest as the source and add src to path
    -> paths(graph, e.dest, dest, path+src)


9. Dijkastra's Algorithm
(1hr 30min+)

(gaand faaad code h iska)
*shortest path from a given source to all the nodes in the graph (weighted & directed graph).
It is a greedy algorithm in graphs.

Logic behind Dijkastra's Algo:
Taking 3 nodes 0, 1 and 2:
	0 to 1 edge wt = 2
 	1 to 2 edge wt = 4
	there is no direct path from 0 to 2

0 is the src node:
** If there exist a direct path from the src node to another node then the distance from the src node to the dest
node becomes equal to the weight of the edge. If there is no direct path from src to the dest node then the distance
between the nodes is said to be infinity so
0 to 1 distance = 2
0 to 2 distance  = infinity as there exist no direct path

0 is the src node, 1 is 'u' and 2 is 'v':
dist[u] = 2
wt(u,v) = 4  (weight of the edge between u and v)
dist[v] = infinity

**main logic behind the code:
if dist[u] + wt(u,v) is less than dist[v] then
dist[v] = dist[u] + wt(u,v)

*initially take the distance from src to all other nodes as infinity
    -> add wt property to the edge class
    -> create a pair class that implements comparable interface
    -> it stores the node and the path, both integers
    -> compareTo = return this.path - p.path
    -> creat dijkastra function that takes the graph and int src as the input
    -> create a dis[graph.length] array and initialize all the values as infinity except the src node
    -> create a boolean vis[graph.length] array and a PriorityQueue <Pair> pq = new PriorityQueue
    -> add (new Pair(0,0) ) to the pq
    -> traverse the pq using while loop until !pq.isEmpty()
    -> Pair curr = q.remove()
    -> if curr.node is not visited
    -> first mark the node as visited
    -> for loop form 0 to graph[curr.node].size()
    -> Edge e = graph[curr.node].get(i)
    -> int u = e.src
    -> int v = e.dest
    -> int w = e.wt
    -> if the sum of dis[v] and w is less than dis[u]
    -> update dis[u] = dis[v] + w
    -> after the while loop output all the values of the dis[] array


10. Bellman Frod's Algorithm

*shortest path from source to all vertices, supports negative vertices that Dijkastra'a Algo does not support.
Note: does not work for negative weighted cycle

    -> create a function BF that takes graph as the input
    -> create a dis[graph.length] array 
    -> initialise all the index as infinity except the source node
    -> 1st for loop 0 to V-1  (V = graph.length)
    -> 2nd for loop 0 to graph.length
    -> 3rd for loop 0 to graph[j].size()
    -> Edge e = graph[j].get(k)
    -> int u = e.src
    -> int v = e.dest
    -> int w = e.wt
    -> if dis[u] != infinity and dis[u] + w is less than dis[v]
    -> update dis[v] with dis[u] + w
    -> after all 3 for loops output the values stored in dis[] array


11. Prim's Algorithm

*MST (minimum spanning tree)
A MST is a subset of edges of a connected edge weighted graph that connects all the vertices
together without any cycle and with minimum possible total edge weight.
** sum of weight = minimum possible

    -> create a Pairs class that implements the Compareable interface
    -> it stores the cost and the vertex and sorts based on cost i.e this.cost - p.cost
    -> the main prims function takes the graph as the input
    -> create a boolean[] vis array of size graph.length
    -> create a PriorityQueue <Pair> q = new PriorityQueue<>()
    -> add new Pair(0, 0) to q and create a new variable int cost = 0
    -> traverse q using while loop
    -> Pair curr = q.remove()
    -> if curr.v is not visited
    -> 1st mark curr.v as visited and add curr.c to the cost (variable we created)
    -> for loop 0 to graph[curr.v].size()
    -> Edge e = graph[curr.v].get(i)
    -> q.add(new Pair(e.dest, e.wt))
    -> after while loop is finished return cost


Q 3. Cheapest Flight with K stops
    -> take n = flights.length where flights is a 2D array
    -> create a graph of size == n and push the graph and flights array into create graph function
    -> create a distance array dis[] = new int[n]
    -> except the src node put all the values in dis[] array == +infinity
    -> create a Queue using Info class 
    -> Info class contains vertex, cost and the no. of stops
    -> add vertex = src, cost = 0 and stops = 0 in the queue
    -> run a while loop until queue is not empty
    -> Info curr = q.remove()
    -> if curr.stops becomes greater than k break the loop
    -> for loop from 0 to graph[curr.vertex].size()
    -> Edge e = graph[curr.vertex].get(i)
    -> v = e.dest and w = e.wt
    -> if curr.cost + w is less than dis[v] and curr.stops <= k then dis[v] = curr.cost + w
    -> q.add( new Info(e.dest, dis[v], curr.stops+1) )
    -> after while loop check if dis[dest] is +infinity, if true return -1
    -> else return dis[dest]


Q 4. Connecting Cities
    -> create a edge class that will contain the destination and the cost
    -> @Override and return this.cost - e.cost (ascending/increasing order)
    -> create a connectCities function that takes a 2d array (int[][] cities) as input
    -> create a variable finalCost = 0 to store the cost and return it at last
    -> create a boolean[] vis array with length == cities.length
    -> create a PQ with Edge type and add new Edge(0, 0) initially
    -> run a while loop until PQ is not empty
    -> Edge curr = pq.remove()
    -> if curr.dest is not visited 
    -> mark vis[curr.dest] == true
    -> update finalCost i.e. += curr.cost
    -> for loop from 0 to cities[curr.dest].length
    -> if cities[curr.dest][i] is not equal to 0
    -> add new Edge( i, cities[curr.dest][i] ) to the pq
    -> after the while loop return finalCost


12. Disjoint Set
(union and find)

Logically stores elements in form of groups/sets. We use find function to find to which set does the element
belongs to and union function to join 2 sets and make them into a single group.

Implementation:
Parent . union by rank
We use 2 arrays par[] and rank[] where initially the element itself is the parent and the rank of all the elements is 0.
find -> returns the leader/parent of the groups/set
union -> joins the groups/sets
*union is always done between the leaders/parents of the two groups/sets.     

    -> create a global variable int n = 7 (or any size)
    -> create two global arrays par[n] and rank[n]
    -> create void function init() to initialize the parents of each node (par[i] == i)
    -> create a function find that takes an integer as the input
    -> if x == par[x] return x
    -> else call the function for par[x]
    -> create a union functin that take two integers as the inputs
    -> create a variable int parA to store the parent of integer a
    -> create a variable int parB to store the parent of integer b
    -> parA = find(a) and parB = find(b)
    -> if rank of both parents is same make any one of them as the parent and increase its rank
    -> else if rank of parA is greater make it the parent of parB and increase its rank
    -> last case (else) make parB the parent of parA and increase its rank

Optimisation (path compression):
int find(int x) {
	if(x == par[x]) return x;
	return par[x] = find(x);
}
    -> par[x] = find(x) is the optimisation.
    -> we will store the parent for the current node that find function will return
    -> after this we don't have to call the find function for all the element
    -> it would make the supreme leader the parent of all the element
    -> eg:
	if 3 was the parent of 6 and 6 is the parent of 4 but the parent of 3 is 1, so we would make 1 the parent of 6 as well
	as the parent of 4 so the path gets compressed and the 1 becomes the parent of 3, 4 and 6 as the find function previously
	aslo would have returned 1 if we called it for any element i.e. 3, 4 or 6.


13. Kruskal's Algorithm
Algorithm used to find out MST, Greedy Approach.
1. Stores Edges
2. Take minimum cost edges (does not form cycle)
V nodes -> V-1 edges are needed

    -> create Edge class the implements Comparable interface
    -> it contains the src, dest & wt and return this.wt - e.wt
    -> create a function kruskal that takes int V as input
    -> AL<Edge> edges = new AL<>() and pass it into createGraph function
    -> call the init() function to initialize the parents of nodes
    -> use Collections.sort(edges) to sort the edges in ascending order
    -> create integers mst and cnt and initialise them with 0
    -> for loop (int i=0; cnt < V-1; i++)
    -> Edge e = edges.get(i)
    -> parA = find(e.src)
    -> parB = find(e.dest)
    -> if parA and parB are not equal union(e.src, e.dest) 
    -> add e.wt to mst and increase cnt by 1 (cnt++)
    -> lasty return mst


























 















