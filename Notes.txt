Stack:
													
1.Push at bottom
    -> when empty push element
    -> top = s.pop()
    -> push(top) in backtracking

2. Reverse Stack
    -> top = s.pop()
    -> reverse(s)
    -> push at bottom(s, top) backtracking step



Queue:

1. 1st Non-repeating letter **
    -> a freqency arr[26] and a Character queue
    -> loop the string => c = s.charAt(i)
    -> increase the freqence of character freq[c-'a']++
    -> add the character (c) to the queue
    -> remove "c" from queue while !isEmpty() and freq[q.peek()-'a'] > 1
    -> if q.isEmpty() sot("-1") else sot(q.peek())

2. Interleave two halfs of Queue
    *even length case only possible
    -> add last half element of queue in another queue
    -> create a final queue using the two queues
    -> add 1st element from Q1 and 2nd element from Q2



Linked List:

1. Reverse Linked List
    -> point the tail at the head
    -> Three pointers prev, curr and nxt
    -> prev = null, curr = head and nxt = curr.next (initially its null)
    -> while ( curr != null): 
	inside the while loop initialize the nxt pointer to curr.next,
        	we would reverse the links between the nodes by pointing the 
 	curr.next to the prev pointer and the next of the nxt pointer 
	to the curr pointer, after this we would update the prev pointer
	to point at curr pointer and the curr pointer will point at nxt.
    -> lastly we would update our original head == prev.

2. Detect and Remove Cycle (Floyd's Algo)
* we use fast and slow pointer appoach to find the cycle in the linked list.
    -> fast += 2 and slow += 1
    -> if they meet at any point which means a cycle exists in the linked list (LL)
    -> when they meet stop the loop and initialize slow with head (slow == head)
    -> use a prev pointer to track the prev node (prev = fast inside while loop)
    -> increase both fast and slow pointer by 1 (while slow != fast)
    -> when they meet again => prev.next = null

3. Check Palindrome**
*we can simply push the elements of our linked list in an arrayList and
check if the arrayList is a palindrome but we would be using the slow 
fast pointer approach to find the center of linked list and the concept 
of reversing half linked list.
    -> find the middle of the list
    -> reverse the second half of the list
    -> compare the 1st and the reversed 2nd half of the list

4. Mergesort
    -> first find the mid of the linked list
    -> return type of the function will be node
    -> right head will be the next of mid
    -> point the next of mid to null this would create to linked list
    -> for left part call for head and for right call for mid.next
    -> lastly call the merge function
    -> create a new linked list with a single node(-1) and temp pointing at its head
    -> merge function will be similar to the one used in arrays

5. Reverse DLL
* just add a line curr.prev = next in the code we used to reverse a SLL.



Recursion & Backtracking:

1. Subset
    -> Yes condition (ans + character)
    -> No condition (ans, pass empty string)

2. Permutation
    -> for loop (recursion inside it)
    -> newString = substr(0, i) + substr(i+1)
    -> func( newString, ans + c)
    -> c = character remove from original string

3. Qiuck Sort
    -> s >= e return
    -> pivot = choose the last element
    -> i = starting index - 1
    -> arr[j] < pivot = perform swap
    -> call for left and right part of pivot

4. Merge Sort
    -> s >= e return
    -> call for s to mid and mid+1 to e
    -> perform merge on left and right part
    -> left = mid-s+1 (size)  arr[i+s]
    -> right = e-mid (size)   arr[i+mid+1]

5. nQueens 
    -> have a char[][] 2d array i.e. board[][] = new char[n][n] of size n X n
    -> a row variable to track the no. of rows
    -> when the row becomes 0 print he board and return
    -> for every board[row][col] put it equal to 'Q'
    -> call the recursive function function and increase the row by one
    -> remve the 'Q' from board[row][col] == 'x' in the backtracking step
    -> create and isSafe function to check if the position of the queen is safe or not:
	1. check straight upwards (col remains constant)
	2. check diagnol left
	3. check diagnol right (tricky one)



BT (Binary Tree):

1. Level Order Traversal
    -> create a Queue <Node> q = new LinkedList<>();
    -> run a while loop until q is empty
    -> remove the 1st element from 'q' and store in a curr node
    -> if curr is null there are two cases:
 	1. if 'q' gets empty break
	2. else print next line and add null to 'q'
    -> if curr is not null then:
	1. print the data
	2. add curr.left if exists
	3. add curr.right if exists

2. kth ancestor of a node 
   -> found == return 0
   -> root is null == return -1 
   -> call for left and right
   -> left && right == -1 return -1 
   -> max == Math.max(left, right) + 1

3. Lowest Common Ancestor
    -> root == null return null
    -> found a || b return root
    -> call for left and right
    -> left && right != null return root
    -> one null return other

4. Min distance b/w 2 nodes
    -> find LCA
    -> null return -1, found return 0
    -> call for left and right
    -> left, right == -1 return -1
    -> one null return other + 1

5. Tronsform to Sum Tree
    -> root == null return 0
    -> call for left and right
    -> data = root.data (return at end);
    -> newLeft(nL) == 0 if (root.left == null) else root.left.data
    -> newRight(nR) == 0 if(root.right == null) else root.right.data
    -> root.data = nL + nR + L + R

6. Top View
    -> use queue and hashmap
    -> create an Info class to store horizontal distance and the node
    -> create queue using Info class
    -> create hashMap with hd as the key and node as the value
    -> take min and max variable to store the min hd and max hd
    -> now run the while loop until q.is not empty
    -> use Info curr = q.remove() and if curr == null check if q.is empty or not(break if empty)
    -> else check if map does not contain the hd and add the node add hd to the map
    -> if node left is not null update the min and add left of node to queue same for right

6. Sub tree of another tree ***
    (covers 2-3 questions)
    -> root == subRoot call isIdentical
    -> return root.left, subRoot || root.right, subRoot
    -> isIdentical:
	both null = false
	one null || root.data != subRoot.data = false;
	call for left (not case) = false
	call for right (not case) = false



BST (Binary Search Tree):

1. Build BST 
    -> pass root and the data to the function
    -> if root is null make root the new Node containing data and return it
    -> if data is smaller than root.data then insert in the left subtree
    -> if data is greater than root.data then insert in the right subtree
    -> return root in the end
    -> print inorder sequence to check if the tree build is correct or not

2. Delete nodeâ€Ž
    -> 1st check for node in left and right of tree 
    -> no child = return null
    -> 1 child = return (left || right) whichever is not null
    -> 2 children = inorderSuccessor
    -> IS = left most child of right tree
    -> root.data = IS.data then delete (root.right)

3. Root - Leaf paths
    -> parameter = root, AL
   -> each step add root.data to AL
   -> l & r == null output AL data
   -> run for left and right
   -> backtracking AL.remove(AL.size() - 1)

4. Validate BST
    -> null = return true
    -> max!=null and left > max same for right (min)
    -> left = min(null), max(root)
    -> right = min(root), max(null)
    -> finally return (left && right)

5. Sorted array to BST 
    -> array(arr)  start(s) end(e)
    -> s > e = return null
    -> using mid create a new node
    -> left = s to mid-1
    -> right = mid+1 to e
    -> use preorder to check if the function is correct

6. Larges BST ***
    -> Info (isBST, size, min, max)
    -> root == null (true, 0, +infinity, -infinity)
    -> call for left and right
    -> calculate size = left.size + right.size + 1
    -> calculate min from root.data, left.min and right.min
    -> calculate max from root.data, left.max and right.max
    -> root.data <= left.max || >=right.min (false condition)
    -> left.isBST && right.isBST == true update max(maxBST, size)
    -> lastly return false condition

7. Merge 2 BST:
    -> AL <Integer> inorder
    -> add values in AL = inorder from both BSTs
    -> sort (inorder)
    -> inorder (sorted array) to BST



Heap (Priority Queues):

-> PriorityQueue <Integer> pq = new PriorityQueue<>( Comparator.reverseOrder() );
    -> to sort the priority queue in descending order.

-> class Name implements Comparable<Name> 
    @override
    public compareTo(Name n)
              return ( this.rank - n.rank )   (ascending order)
	    return ( n.rank - this.rank )   (descending order)

-> children <= parent (max heap)
-> children >= parent (min heap)

-> parent = (index-1)/2
-> left = 2*index + 1		(0 based indexing)
-> right = 2*index + 2

-> CBT(complete binary tree):
    It is a tree which has all the levels completely filled
    except the last left, node are fill from left to right.
         
1. Sliding Window:
    -> PriorityQueue of Pair class type
    -> Pair class uses implements Comparable function (val, idx)
    -> p.val - this.val (descending order)
    -> add first k elements to PQ 
    -> res array = n-k+1 (size of the answer array) 
    -> res[0] = p.peek().val (the first value in our priority queue)
    -> while index of 1st element in pq is <= (i-k) => q.remove() 



Hashing:

-> HashMap <key(type), value(type)> m = new HashMap<>()    (no defined order of element)
-> LinkedHashMap <K,V> m = new LinkedHashMap<>()    (output elements in the same order added to the map)
-> TreeMap <K,V> m = new TreeMap<>()    (stored and outputs element in sorted order, sorting based on keys)

1. Majority Element
    -> let number be the key and occurence the value
    -> if m.contains(number) increase occurence
    -> output the max occured m.get(key) > max (update max)

2. Anagram
    -> add the characters of 1st string into a hashMap
    -> HashMap < Character, Integer (occurence) > m = new HM<>()
    -> check if( m.get(character of 2nd string) != null) exists in map or not
    -> now compare if(m.get(character of 2nd string) == 1) m.remove(ch)
    -> else decrease the value of occurence ( m.put(ch, m.get(ch)-1) )
    -> if does not exists in 1st string (map) return false
    -> if map isEmpty() return true  ( return m.isEmpty() )

3. Subarray Sum 0**
    -> HashMap <sum, index> m => we will store the index of sum
    -> if we find sum in our map update len (largest subarray)
    -> subLen = j - m.get(sum) length of the subarray with sum 0 
    -> compare it with len = Math.max(len, subLen)   

*Here if we get the sum again at any point in the array it means that the sum 
  we calculated has already occured before in the array and if we take the 
  sum of the elements between the current index (where we found the sum) 
  and the previous index+1 (where we found the sum 1st time) it would be 0.
  j - m.get(sum) would give us the length of the current subarray with sum = 0.
  This works only when we need to find the subarray with max length, we can
  output the largest subarray but we cannout output all the subarrays with 0 sum.  	

4. Subarray Sum k***
    -> sum(j)-sum(i) == k we can deduce  sum(j)-k == sum(i)
    -> HashMap <sum, count> m => we would store freqency of sum
    -> put sum=0 and count=1 by default in the map
    -> if we find the sum-k in our map we would update the ans
    ->  ans += m.get(sum-k) => here we will add the count of the sum in ans
    -> we would always store our sum/increase its frequency in each step
    -> m.get(sum, m.getOrDefault(sum, 0)+1)
    -> lastly output the ans


-> HashSet <Integer> s = new HashSet<>() (unodered, no defined order)
	-> Iterator it = set.iterator()
  	-> while ( it.hasNext() ) sot( it.next() )	
	-> for ( dataType variableName : HashSetName )

-> LinkedHashSet <Integer> s = new HashSet<>()  (output in the same order we inputed)
-> TreeSet <Integer> s = new TreeSet<>()  (sorted in ascending order)



Tries:
* tries are prefix trees also known as re'trie'val (the name comes from here) trees which work 
on prefix of words, the are k-nary trees and are bulky, requires huge amount of space but gives us 
a nice time complexity, as the height of the tree decreases the time complexity of also decreases.
k-nary -> number of children of a node can be from 0 to k.

Creating
    -> define a Node class with an array of nodes[26] and a boolean EndOfWord (eow)
    -> create a constructor and initialize nodes[26] = null using forLoop
    -> create root node ( Node root = new Node() ) that remains empty
Inserting
    -> initialize a curr node == root node
    -> traverse the given word and store the index of the character in idx variable
    -> if the character does not exist create a node 
    -> point curr at the children that exists/is created 
    -> after exiting the for loop eow == true
Searching
same as inserting just if the index does not exist return false and at the end return eow

1. Word Break ***
    -> insert the array of words into a trie
    -> create a function wordBreak that takes the key as the input
    -> using a for loop traverse the key string
    -> search for the key.substring(0,i) in the try
    -> call wordBreak for the left part if the key.substring(i)
    -> if both gives the ouput as true return true
    -> if the length of key becomes 0 return true (base condition)
    -> finally return false 

2. Prefix Problem ***
    -> add another property frequency(freq) to the Node class
    -> initialise it by 1 when creating a Node
    -> insert the node and if already present increase the freqency

*Note: frequency of root node should be initialized as -1 before passing to the function
    -> pass two parameters root and an empty string (ans) to the function
    -> if root becomes null return
    -> if the freq of root becomes 1 output the answer and then return
    -> traverse all the childrens of root using a for loop
    -> if the children is not null call the function for the children and add the word to the an
    -> if we are using stringBuilder (inside for loop):
                char c = (char)(i+'a');
                ans.append(c);
                prefix(root.children[i], ans);
                ans.deleteCharAt(ans.length()-1);






























